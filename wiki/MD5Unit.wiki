#summary MD5 Message Digest Unit documentation.
<wiki:comment>
$Rev$
$Date$
</wiki:comment>

= MD5 Message Digest Unit =

This unit contains an implementation of the MD5 message digest algorithm. It is implemented as a Delphi Class named _[TPJMD5 TPJMD5]_.

The code is developed from scratch based on the algorithm presented in [http://www.faqs.org/rfcs/rfc1321.html RFC 1321]. Portions of the code are translated from the reference C code supplied in the RFC. Note though that the code is not a literal translation into Pascal from the reference C code.

_The algorithm and reference code are copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All rights reserved._

*The code is currently in beta and the interface is liable to change*

No stable version of the project has not yet been released, so there neither a zip file available on the Downloads page nor a release tag in the repository. You can grab `PJMD5.pas` from the repository trunk, but be warned this is development code and may not be stable. If you grab code that won't compile choose an earlier revision and try again.

[http://dunit.sourceforge.net/ DUnit] tests for the code are available to help you test the code's accuracy - and the code is in a state where it can pass the tests.

== Rationale ==

So why write this code?

Well, I've been searching for a more up-to-date implementation of the MD5 message digest in Delphi that meets these criteria:

  # No dependency on C .obj files or DLLs - i.e. I want pure Pascal code.
  # Open source with a license compatible with the MPL because I want to use it in an MPLd application of mine, so GPL-only code is ruled out.
  # Compiles and works with the Unicode Delphi Compilers.
  # Object oriented.
  # Easy to get an MD5 digest from all sorts of data without messing around converting it and playing with contexts etc.

The version I'd been using passed the first 2 tests but failed the last three. And it is no longer being updated. And it took me quite some time to persuade it to work in the Unicode world of Delphi 2010.

Seems easier to start again somehow. So here's my attempt.

== Mini Tutorial ==

This is a quick overview of how to use the class:

  * Construct an instance of _TPJMD5_.

  * Call one of the overloaded _Process_ methods to update the digest from the supplied data. Check the source code to see what data types are supported.

  * Optionally add some further data.

  * Alternatively read and process a file using the _!ProcessFile_ method.

  * Call the _Finalize_ method to complete the calculation.

  * Get the digest from the _Digest_ property. Note that calling this propertY will finalize the digest for you, so you can skip the _Finalize_ call if you want. Assign _Digest_ to a string or read it in a string context to get the string representation of the digest.

  * If you want to get the MD5 digest of more data call the _Reset_ method before using one of the _Process_ methods again. You will get an exception if you don't.

  * When reading from streams or files the input is read into a buffer in 64Kb chunks by default. Set _!ReadBufferSize_ to change the default size of the input buffer.

Here's an example of getting the MD5 of all the data in a _TStream_. We're assuming that some data has been written to the stream. 

{{{
var
  Stm: TStream;
  MD5: TPJMD5;
  MD5Str: string;
begin
  // put some data in the stream
  Stm.Position := 0;
  MD5 := TPJMD5.Create;
  try
    MD5.Process(Stm);
    MD5Str := MD5.Digest;   // Digest casts automatically to string
    // do something with MD5Str
  finally
    MD5.Free;
  end;
end;
}}}

=== New Static Helper Methods ===

Since revision 442 there is also the option to call one of the overload static _Calculate_ methods. This has the advantage that you don't need to construct and free an instance of the class. There are some limitations - for example, you can't change the buffer size for file and stream processing.

Each _Calculate_ method returns a binary message digest, not the string version. However, changes to the _TPJMD5Digest_ type mean that you can implicitly cast a _TPJMD5Digest_ value to a string. _TPJMD5Digest_ is now implemented as a record instead of an array of bytes and has operator overloads that permit it to be cast to and from _TBytes_ and _string_ types. 

The following example shows how to get the MD5 of a stream with _Calculate_:

{{{
var
  Stm: TStream;
  MD5: TPJMD5;
  Digest: TPJMD5Digest;
  MD5Str: string;
begin
  // put some data in the stream
  Stm.Position := 0;
  Digest := TPJMD5.Calculate(Stm);
  // want digest as string: just assign it to one
  MD5Str := Digest;
  // do something with MD5Str
end;
}}}

Getting the MD5 hash as a string could have been even shorter:

{{{
  MD5Str := TPJMD5.Calculate(Stm);
}}}

=== Comparing Digests ===

The new implementation of _TPJMD5Digest_ supports comparison for equality and inequality. So to check if one digest is the same as another (or is not the same), you simply compare them:

{{{
var
  D1, D2: TPJMD5Digest;
begin
  D1 := TPJMD5.Calculate(AnsiString('foo'));
  D2 := TPJMD5.Calculate(UnicodeString('foo'));
  if D1 = D2 then ShowMessage('No way!');
  if D1 <> D2 then ShowMessage('Just as I thought');
end;
}}}

What is more if you've save one hash as a string and want to compare to another digest, operator overloading lets you do this: you can compare strings and _TBytes_ arrays with _TPJMD5Digest_ records. The following example shows this for strings:

{{{
var
  D: TPJMD5Digest;
  MD5Str: string;
begin
  D := TPJMD5.Calculate(AnsiString('a'));
  MD5Str := '0cc175b9c0f1b6a831c399e269772661';
  if D = MD5Str then ShowMessage('Passed RFC test #1');
  if D <> MD5Str then ShowMessage('Failed!');
end;
}}}

And, yes I know that an `else` would have done instead of an inequality test above - just trying to show you that the `<>` operator overload works!
