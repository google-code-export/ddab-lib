#summary Description of the TPJMD5.Calculate methods.
<wiki:comment>
$Rev$
$Date$
</wiki:comment>

= Calculate methods =

*Project:* [MD5Unit MD5 Message Digest Unit].

*Unit:* _PJMD5_.

*Class:* _[TPJMD5 TPJMD5]_

== Description == 

There a several different overloaded versions of the _Calculate_ method. Each method provides a useful shortcut when all you need to do is create an MD5 hash of a single data item, for example, of a stream, a string or a byte array. You can do this with just one method call with _Calculate_ - there is no need to create a _[TPJMD5 TPJMD5]_ instance.

The disadvantages are: 

  # Only one "resource" can be processed.
  # The size of the read buffer used when processing streams cannot be changed.

=== The Methods ===

==== TBytes versions ====

{{{
class function Calculate(const X: TBytes;
  const Size: Cardinal): TPJMD5Digest; overload;
class function Calculate(const X: TBytes): TPJMD5Digest; overload;
}}}

These methods generate a MD5 digest from a _TBytes_ array. The first version processes _Size_ bytes from the beginning of byte array _X_. Here _X_ must have at least _Size_ elements. The second version processes all the content of byte array _X_.

==== Untyped Buffer vesion ====

{{{
class function Calculate(const Buf; const Size: Cardinal): TPJMD5Digest;
  overload;
}}}

Calculates a digest from _Size_ bytes read from untyped buffer _Buf_. _Buf_ must
contain at least _Size_ bytes.

==== Ansi string version ====

{{{
class function Calculate(const S: AnsiString): TPJMD5Digest; overload;
}}}

Calculates a digest from the ordinal values of characters of ANSI string _S_.

==== Unicode string versions ====

{{{
class function Calculate(const S: UnicodeString;
  const Encoding: TEncoding): TPJMD5Digest; overload;
class function Calculate(const S: UnicodeString): TPJMD5Digest; overload;
}}}

Each of these methods creates a digest Unicode string _S_. Before processing the string it is converted to a sequence of bytes. The first version uses the encoding passed in the _Encoding_ parameter to perform the conversion while the second version uses the _TEncoding.Default_ encoding.

==== TStream versions ====

{{{
class function Calculate(const Stream: TStream;
  const Count: Int64): TPJMD5Digest; overload;
class function Calculate(const Stream: TStream): TPJMD5Digest; overload;
}}}

This pair of methods calculate a digest from the bytes read from a stream. Bytes are always read from the current position in _Stream_. To read the from the start of the stream set its _Position_ property to 0. Both methods modify the stream's _Position_ property.

The first version reads _Count_ bytes from the stream if possible. If _Count_ is too large then all the remaining bytes in the stream are read. The second version reads to the end of the stream, processing `Stream.Size - Stream.Position` bytes.

The stream is read in chunks. The size of a chunk is given by _[TPJMD5 TPJMD5]_'s _!DefReadBufferSize_ constant. This buffer size cannot be changed. If you need to change the buffer size you must create a _[TPJMD5 TPJMD5]_ instance, set the buffer size using the _!ReadBufferSize_ property, then use the appropriate _[TPJMD5Process Process]_ method. 

=== Examples ===

Create an MD5 digest of a _TStream_ referenced by _Stm_. Assume the stream has been created and contains data:

{{{
var
  Digest: TPJMD5Digest;
begin
  ...
  Stm.Position := 0;
  Digest := TPJMD5.Calculate(Stm);
  ...
end;
}}}

Create an MD5 digest of an array of bytes, _A_ of type _TBytes_. Assume that the byte array contains data:

{{{
var
  Digest: TPJMD5Digest;
begin
  ...
  Stm.Position := 0;
  Digest := TPJMD5.Calculate(A);
  ...
end;
}}}

Create an MD5 digest of an _!AnsiString_:

{{{
var
  Digest: TPJMD5Digest;
  S: AnsiString;
begin
  S := 'Hello World';
  Digest := TPJMD5.Calculate(S);
  ...
end;
}}}
